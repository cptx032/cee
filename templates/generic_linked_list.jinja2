{%- block includes -%}
#include <stdlib.h>
#include <stdbool.h>
#include <hf/Arena.c>
{%- if include_list %}
{%- for include_item in include_list %}
{{ include_item }}
{%- endfor %}
{%- endif %}
{%- endblock %}

#ifndef __{{ name | upper }}
#define __{{ name | upper }}

{%- block codeblock %}

typedef struct {{ name }}
{
    {%- for field in fields %}
    {{ field.type }} {{ field.name }};
    {%- endfor %}

    Arena *arena;
    struct {{ name }} *next;
    struct {{ name }} *first;
    struct {{ name }} *last;
    int length;
} {{ name }};


bool {{ name | lower}}_is_empty({{ name }} *start)
{
    if (!start)
    {
        return true;
    }
    return start->first->length == 0;
}

{% block object_creation %}
{{ name }} *{{ name|lower }}_new(Arena *arena)
{
{%- with var_name="new_"+name.lower() %}
    {{ name }} *{{ var_name }} = arena_malloc(arena, sizeof({{ name }}));

    {%- for field in fields %}
    {{ var_name }}->{{ field.name }} = NULL;
    {%- endfor %}

    {{ var_name }}->next = NULL;
    {{ var_name }}->first = {{ var_name }};
    {{ var_name }}->last = {{ var_name }};
    {{ var_name }}->arena = arena;
    {{ var_name }}->length = 0;
    return {{ var_name }};
{%- endwith %}
}
{% endblock %}

{{ name }} *{{ name|lower }}_append(
    {{ name }} *start,
    {%- for field in fields %}
    {{ field.type }} {{ field.name }}{% if not loop.last %},{% endif %}
    {%- endfor %}
)
{
    if (!start)
    {
        return NULL;
    }
    {%- if not allow_nulls %}
    {%- for field in fields %}
    if ({{ field.name }} == NULL)
    {
        return NULL;
    }
    {%- endfor %}
    {%- endif %}

    if ({{ name|lower }}_is_empty(start))
    {
        {%- for field in fields %}
        start->{{ field.name }} = {{ field.name }};
        {%- endfor %}

        start->next = NULL;
        start->last = start;
        start->first = start;
        start->length++;
        return start;
    }

    start->length++;

    {{ name }} *new_node = {{ name|lower }}_new(start->arena);
    {%- for field in fields %}
    new_node->{{ field.name }} = {{ field.name }};
    {%- endfor %}

    new_node->first = start;

    start->last->next = new_node;
    start->last = new_node;
    return new_node;
}

{{ name }} *{{ name|lower }}_choice({{name}} *start)
{
    if (start->length <= 0) {
        return NULL;
    }
    int random_index = rand() % start->length;
    int count = 0;
    {{ name }} *current = start;
    while (count < random_index)
    {
        count++;
        if (current->next)
        {
            current = current->next;
        }
    }
    return current;
}

{# fixme > remove_by_index() #}
{#- fixme > remove_by_natural_key() -#}
{#- fixme > allow duplicated natural key -#}
{#- fixme > get_many_by_natural_key -#}

{%- if fields | selectattr("natural_key", "equalto", true) | list | length > 0 -%}

bool {{ name|lower }}_equal_by_natural_key(
    {{ name }} *start,
    {% set items = [] %}
    {%- for field in fields -%}
      {%- if field.natural_key -%}
        {%- set _ = items.append(field.type ~ ' ' ~ field.name) -%}
      {%- endif -%}
    {%- endfor -%}
    {{ items | join(', ') }}
)
{
    if (!start)
    {
        return false;
    }
    {%- for field in fields %}
    {%- if field.natural_key %}
    {%- if field.type.lower().strip() == "char*" %}
    if (strcmp(start->{{ field.name }}, {{ field.name }}) == 0)
    {%- else %}
    if (start->{{ field.name }} == {{ field.name }})
    {%- endif %}
    {
        return true;
    }
    {%- endif %}
    {%- endfor %}
    return false;
}


{{ name }} *{{ name|lower }}_get_one_by_natural_key(
    {{ name }} *start,
    {% set items = [] %}
    {%- for field in fields -%}
      {%- if field.natural_key -%}
        {%- set _ = items.append(field.type ~ ' ' ~ field.name) -%}
      {%- endif -%}
    {%- endfor -%}
    {{ items | join(', ') }}
)
{
    while(start && !{{ name|lower }}_is_empty(start))
    {
        if ({{ name|lower }}_equal_by_natural_key(start, {{ fields | selectattr("natural_key", "equalto", true) | map(attribute="name") | join(", ") }}))
        {
            return start;
        }
        start = start->next;
    }
    return NULL;
}


bool {{ name|lower }}_contains_by_natural_key(
    {{ name }} *start,
    {% set items = [] %}
    {%- for field in fields -%}
      {%- if field.natural_key -%}
        {%- set _ = items.append(field.type ~ ' ' ~ field.name) -%}
      {%- endif -%}
    {%- endfor -%}
    {{ items | join(', ') }}
)
{
    {{ name }} *found = {{ name|lower }}_get_one_by_natural_key(start, {{ fields | selectattr("natural_key", "equalto", true) | map(attribute="name") | join(", ") }});
    if (found) {
        return true;
    }
    return false;
}
{% endif %}

{% endblock %}
#endif
